#!/bin/bash

show_help() {
    cat << 'EOF'
claudo - Run Claude Code in a Podman container

Usage: claudo [OPTIONS] [--] [COMMAND...]

Options:
  -e KEY=VALUE    Set environment variable in container (can be used multiple times)
  -m, --mount PATH  Mount additional directory inside current workspace (repeatable)
                    Use PATH for auto-naming, or PATH:/container/path for explicit destination
                    Append :rw for read-write (default is read-only): PATH:rw or PATH:/dest:rw
  -p, --prompt PROMPT  Run claude with -p (prompt mode)
  -i, --image IMG Use specified container image (default: $CLAUDO_IMAGE or built-in)
  --host          Use host network mode
  --no-sudo       Disable sudo (adds no-new-privileges restriction)
  --no-privileges Drop all capabilities (most restrictive)
  --no-network    Disable network access (breaks Claude Code)
  --docker-socket Mount host Docker socket (sibling containers, host root equivalent)
  --git           Mount git config (~/.gitconfig and credentials) for committing
  --ssh           Mount SSH keys and forward SSH agent for GitHub auth
  --pull          Always pull the latest image before running
  -n, --name NAME Create a named container 'claudo-NAME' that persists after exit
  -a, --attach NAME  Attach to existing container 'claudo-NAME'
  --tmp           Run isolated (no directory mount, workdir /workspaces/tmp)
  -v, --verbose   Display podman command before executing
  --dry-run       Show podman command without executing (implies --verbose)
  --docker-opts OPTS  Pass additional options to podman run
  -h, --help      Show this help message

Arguments after -- are passed to claude if they start with -, otherwise as the container command.

Examples:
  claudo                          Run claude --dangerously-skip-permissions (default)
  claudo -e API_KEY=xxx           Start with environment variable
  claudo -m ~/projects/lib        Mount ~/projects/lib read-only at /workspaces/<cwd>/lib
  claudo -m ~/projects/lib:rw     Mount read-write instead of read-only
  claudo -m /src:/custom/path     Mount with explicit container path (read-only)
  claudo -m /src:/custom/path:rw  Mount with explicit container path (read-write)
  claudo -m ~/p1 -m ~/p2          Mount multiple directories
  claudo -i claudo-base:latest    Use a different image
  claudo --host                   Start with host networking
  claudo --no-sudo                Start without sudo privileges
  claudo --no-privileges          Start with all caps dropped
  claudo --no-network             Start without network access
  claudo --docker-socket          Use host Docker socket (sibling containers)
  claudo --git                    Enable git commits from inside container
  claudo --ssh                    Enable SSH auth for GitHub (plugins, git)
  claudo -n myproject             Start named persistent container
  claudo -a myproject             Attach to existing container
  claudo -- --resume              Resume a conversation (shows picker)
  claudo -- --resume last         Resume the last conversation
  claudo -- -c                    Continue the most recent conversation
  claudo -- zsh                   Run zsh instead of claude
  claudo -n dev -e DEBUG=1 -- -c  Combined options with claude flags

The current directory is mounted at /workspaces/<dirname>.
~/.claudo is mounted at /claude-config for container config.
~/.claude/skills is mounted at /claude-config/skills (read-only).

LLM API environment variables are automatically passed through if set:
  ANTHROPIC_API_KEY, OPENAI_API_KEY, AZURE_OPENAI_API_KEY, GOOGLE_API_KEY,
  GEMINI_API_KEY, MISTRAL_API_KEY, GROQ_API_KEY, and others (AWS, HuggingFace, etc.)
EOF
}

current_dir=$(pwd)
dir_name=$(basename "$current_dir")
# Sanitize directory name for volume mount (colons break -v syntax)
safe_dir_name="${dir_name//:/-}"

env_args=()
network_args=()
mount_args=()
prompt_arg=""
container_name=""
attach_name=""
remove_flag="--rm"
image="${CLAUDO_IMAGE:-ghcr.io/c0ffee0wl/claudo:latest}"
command_args=()
tmp_mode=false
no_sudo=false
no_privileges=false
no_network=false
git_mode=false
ssh_mode=false
docker_socket_mode=false
pull_mode=false
verbose=false
dry_run=false
docker_opts=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        -e)
            env_args+=("-e" "$2")
            shift 2
            ;;
        -m|--mount)
            mount_args+=("$2")
            shift 2
            ;;
        -p|--prompt)
            prompt_arg="$2"
            shift 2
            ;;
        -i|--image)
            image="$2"
            shift 2
            ;;
        --host)
            network_args=("--network" "host")
            shift
            ;;
        --no-sudo)
            no_sudo=true
            shift
            ;;
        --no-privileges)
            no_privileges=true
            shift
            ;;
        --no-network)
            no_network=true
            shift
            ;;
        --docker-socket)
            docker_socket_mode=true
            shift
            ;;
        --pull)
            pull_mode=true
            shift
            ;;
        --git)
            git_mode=true
            shift
            ;;
        --ssh)
            ssh_mode=true
            shift
            ;;
        -n|--name)
            container_name="$2"
            remove_flag=""
            shift 2
            ;;
        -a|--attach)
            attach_name="$2"
            shift 2
            ;;
        --tmp)
            tmp_mode=true
            shift
            ;;
        -v|--verbose)
            verbose=true
            shift
            ;;
        --dry-run)
            dry_run=true
            verbose=true
            shift
            ;;
        --docker-opts)
            docker_opts="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        --)
            shift
            command_args=("$@")
            break
            ;;
        -*)
            echo "Error: Unknown option '$1'" >&2
            echo "Run 'claudo --help' for usage information" >&2
            exit 1
            ;;
        *)
            command_args+=("$1")
            shift
            ;;
    esac
done

# --- Validation ---

if [[ -n "$attach_name" && ${#command_args[@]} -gt 0 ]]; then
    echo "Error: --attach cannot override the container command" >&2
    echo "Use 'podman exec -it claudo-$attach_name ${command_args[*]}' to run a different command" >&2
    exit 1
fi

if [[ "$tmp_mode" != true && "$current_dir" == *:* ]]; then
    echo "Error: Directory path contains ':' which breaks volume mounts" >&2
    echo "Path: $current_dir" >&2
    echo "Use --tmp mode or rename the directory" >&2
    exit 1
fi

# --- Handle attach mode (separate code path) ---

if [[ -n "$attach_name" ]]; then
    full_name="claudo-$attach_name"

    if ! podman ps -a --format '{{.Names}}' | grep -q "^${full_name}$"; then
        echo "Error: Container '$full_name' does not exist" >&2
        echo "Use 'claudo -n $attach_name' to create it first" >&2
        exit 1
    fi

    start_args=(start -ai "$full_name")

    if [[ "$verbose" == true ]]; then
        printf '\e[2mpodman %s\e[0m\n' "${start_args[*]}" >&2
    fi

    if [[ "$dry_run" != true ]]; then
        podman "${start_args[@]}"
    fi
    exit $?
fi

# --- Build podman run command ---

# Ensure config directories exist before mounting
mkdir -p "$HOME/.claudo"
mkdir -p "$HOME/.claude/skills"

# Use -it if stdin is a terminal, otherwise just -i for piped input
if [[ -t 0 ]]; then
    tty_flag="-it"
else
    tty_flag="-i"
fi

# UID mapping: container always runs as UID 1000
# --userns=keep-id is not allowed for root, so use different approach
if [[ $(id -u) -eq 0 ]]; then
    # Root host: create user namespace mapping container UID 1000 to host UID 0 (root)
    # Need full UID range for container to function:
    # - Container 0-999 → Host 1-1000 (shifted)
    # - Container 1000 → Host 0 (root) <-- the key mapping
    # - Container 1001-65535 → Host 1001-65535 (identity)
    userns_args=(
        --uidmap 0:1:1000 --uidmap 1000:0:1 --uidmap 1001:1001:64535
        --gidmap 0:1:1000 --gidmap 1000:0:1 --gidmap 1001:1001:64535
        --user 1000:1000
    )
else
    # Non-root host: use keep-id to map host UID to container UID 1000
    userns_args=(--userns=keep-id:uid=1000,gid=1000)
fi

docker_args=(
    run $tty_flag $remove_flag
    "${userns_args[@]}"
    --hostname claudo
    -v "$HOME/.claudo:/claude-config"
    -v "$HOME/.claude/skills:/claude-config/skills:ro"
    -e "CLAUDE_CONFIG_DIR=/claude-config"
)

# Auto-passthrough LLM API environment variables from host
for var in ANTHROPIC_API_KEY ANTHROPIC_MODEL \
           OPENAI_API_KEY OPENAI_API_BASE OPENAI_ORG_ID \
           AZURE_OPENAI_API_KEY AZURE_OPENAI_ENDPOINT AZURE_OPENAI_API_VERSION \
           GOOGLE_API_KEY GEMINI_API_KEY \
           MISTRAL_API_KEY COHERE_API_KEY HUGGINGFACE_API_KEY HF_TOKEN \
           GROQ_API_KEY TOGETHER_API_KEY REPLICATE_API_TOKEN \
           PERPLEXITY_API_KEY FIREWORKS_API_KEY DEEPSEEK_API_KEY \
           AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AWS_REGION AWS_DEFAULT_REGION \
           CLAUDE_CODE_USE_BEDROCK CLAUDE_CODE_USE_VERTEX CLOUD_ML_REGION \
           CLAUDE_CODE_MAX_OUTPUT_TOKENS CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC; do
    if [[ -n "${!var:-}" ]]; then
        docker_args+=(-e "$var=${!var}")
    fi
done

# Security: --no-sudo adds no-new-privileges restriction
if [[ "$no_sudo" == true ]]; then
    docker_args+=(--security-opt=no-new-privileges:true)
fi

# No privileges mode: drop all capabilities
if [[ "$no_privileges" == true ]]; then
    docker_args+=(--cap-drop=ALL)
fi

# No network mode: disable all network access
if [[ "$no_network" == true ]]; then
    docker_args+=(--network=none)
fi

# Pull mode: always pull latest image
if [[ "$pull_mode" == true ]]; then
    docker_args+=(--pull=always)
fi

# Git mode: mount git configuration files
if [[ "$git_mode" == true ]]; then
    if [[ -f "$HOME/.gitconfig" ]]; then
        docker_args+=(-v "$HOME/.gitconfig:/home/claudo/.gitconfig:ro")
    fi
    if [[ -f "$HOME/.git-credentials" ]]; then
        docker_args+=(-v "$HOME/.git-credentials:/home/claudo/.git-credentials:ro")
    fi
fi

# Docker socket mode: mount host docker socket (siblings mode)
if [[ "$docker_socket_mode" == true ]]; then
    docker_args+=(-v "/var/run/docker.sock:/var/run/docker.sock")
fi

# SSH mode: mount SSH keys and forward SSH agent
if [[ "$ssh_mode" == true ]]; then
    if [[ -d "$HOME/.ssh" ]]; then
        docker_args+=(-v "$HOME/.ssh:/home/claudo/.ssh:ro")
    fi
    if [[ -n "${SSH_AUTH_SOCK:-}" && -S "$SSH_AUTH_SOCK" ]]; then
        docker_args+=(-v "$SSH_AUTH_SOCK:/ssh-agent" -e "SSH_AUTH_SOCK=/ssh-agent")
    fi
fi

# Determine workspace base path for auto-mounts
if [[ "$tmp_mode" == true ]]; then
    workspace_base="/workspaces/tmp"
else
    workspace_base="/workspaces/$safe_dir_name"
fi

# Additional mount points
for mount_spec in "${mount_args[@]}"; do
    # Check for :rw suffix (read-write mode)
    if [[ "$mount_spec" == *":rw" ]]; then
        mount_mode="rw"
        mount_spec="${mount_spec%:rw}"  # Strip :rw suffix
    else
        mount_mode="ro"
    fi

    if [[ "$mount_spec" == *":"* ]]; then
        # Explicit destination: /host/path:/container/path
        host_path="${mount_spec%%:*}"
        container_path="${mount_spec#*:}"
    else
        # Auto destination: /host/path -> inside current workspace
        host_path="$mount_spec"
        mount_basename=$(basename "$host_path")
        # Sanitize basename (replace colons with dashes)
        safe_mount_name="${mount_basename//:/-}"
        container_path="$workspace_base/$safe_mount_name"
    fi
    # Expand ~ to $HOME
    host_path="${host_path/#\~/$HOME}"
    if [[ ! -e "$host_path" ]]; then
        echo "Error: Mount path does not exist: $host_path" >&2
        exit 1
    fi
    docker_args+=(-v "$host_path:$container_path:$mount_mode")
done

if [[ "$tmp_mode" == true ]]; then
    docker_args+=(-w "/workspaces/tmp")
else
    docker_args+=(-v "$current_dir:/workspaces/$safe_dir_name")
    docker_args+=(-w "/workspaces/$safe_dir_name")
fi

if [[ -n "$container_name" ]]; then
    docker_args+=("--name" "claudo-$container_name")
fi

docker_args+=("${env_args[@]}")
docker_args+=("${network_args[@]}")
# shellcheck disable=SC2086
[[ -n "$docker_opts" ]] && docker_args+=($docker_opts)
docker_args+=("$image")

if [[ -n "$prompt_arg" ]]; then
    # Prompt mode: run claude -p with the provided prompt
    docker_args+=("claude" "--dangerously-skip-permissions" "-p" "$prompt_arg")
elif [[ ${#command_args[@]} -eq 0 ]]; then
    if [[ -t 0 ]]; then
        docker_args+=("claude" "--dangerously-skip-permissions")
    else
        # Piped input with no command - send to claude -p
        docker_args+=("claude" "--dangerously-skip-permissions" "-p")
    fi
else
    # If first arg starts with -, treat as claude flags and prepend default command
    if [[ "${command_args[0]}" == -* ]]; then
        docker_args+=("claude" "--dangerously-skip-permissions" "${command_args[@]}")
    else
        docker_args+=("${command_args[@]}")
    fi
fi

if [[ "$verbose" == true ]]; then
    printf '\e[2mpodman %s\e[0m\n' "${docker_args[*]}" >&2
fi

if [[ "$dry_run" == true ]]; then
    exit 0
fi

# --- Execute ---

podman "${docker_args[@]}"
